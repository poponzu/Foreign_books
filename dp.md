# DP 入門

**DPは全探索の高速化**



どうやって高速化するかというと，同じ計算を何度もしないようにするだけ．

これの実現方法がたくさんあって，DPはかなり広い概念になる．





# 非常に簡単な例：累積和

DPを幅広くとらえると，累積和もDPの一種



```python

# 愚直な方法

# A: もとの配列

# B: B[i] := sum(A[0], ... , A[i])

B = [0] * (len(A))

for i in range(len(A)):

    acc = 0 # sum(A[0], ... , A[i])

    for j in range(i+1):

        acc += A[j]

    B[i] = acc



# S: 累積和 S[i] := sum(A[0], ... , A[i-1]), (S[0] = 0)

S = [0] * (len(A) + 1)

for i in range(len(A)):

    # S[i] は sum(A[0], ... , A[i-1]) で前に計算した値の再利用になっている

    # S[i+1] = sum(A[0], ... , A[i]) = sum(A[0], ... , A[i-1]) + A[i]

    # という漸化式に沿って計算できる

    S[i+1] = S[i] + A[i]

```





# 状態 と 遷移

ポイントは **状態** と **遷移** の2つ

上の例では

- 状態： 累積和 S[i] := sum(A[0], ... , A[i-1])

- 遷移：　漸化式

である



DP問題の解き方のコツは，この状態と遷移をしっかりと定義することである



状態と遷移の定め方で解法はかなりたくさんバリエーションが出るので，たくさん問題とその解法を見るのがいい

問題例は [EDPC](https://atcoder.jp/contests/dp)

解答例は [drkenの解説](https://qiita.com/drken/items/dc53c683d6de8aeacf5a)

とりあえず EDPC の ABCDE までやってみるといいと思う





状態遷移のイメージとしては状態を頂点，遷移を辺とする有向グラフになる．

（難しいが，[DPの話](https://tayama-2.hatenadiary.org/entry/20111210/1323502092) を参照）

ループのないグラフなら，矢印の手前の頂点から順番に計算していくことができる



状態の例：

- `DP[i]` := 列Aのi番目 まで見たときの答えの 最大値/最小値/総和

- `DP[i][j]` := 列Aのi番目 まで見て、ボールがj個あるときの答えの 最大値/最小値/総和

- `DP[i][j]` := 列Aのi番目 まで見て、列Bのj番目まで見たときの答えの 最大値/最小値/総和



遷移（漸化式）の例： (f = max | min | sum)

- `DP[i] = f(DP[i-1], DP[i-A[i]])`

- `DP[i][j] = f(DP[i][j-1], DP[i-1][j])`

- `DP[i][j] = f(DP[i-1][0], ..., DP[i-1][j])`



実装方法の例： [drkenの解説](https://qiita.com/drken/items/dc53c683d6de8aeacf5a) を参照

- 配る：状態S から の遷移に注目

- 貰う：状態S へ の遷移に注目

- メモ化再帰（貰う再帰）

どの実装方法もできるようになるとい
